Traveling Salesperson Problem, part 3
by Nicole Niesen and Alex Richter

This README.txt is also included in the extracredit folder. I meant to add it to the front, I apologize. 

For the ClimbChromosome class, we overrode the clone method to return a pointer to a new ClimbChromosome, so we could call clone in the mutate method that we also overrode. In mutate, we clone the ClimbChromosome twice, keeping the chromosome called on as the original and swapping contents of the randomly decided index with either the position in front of or behind it for either clone, wrapping when the position was the beginning or the end. Then we set the original chromosome's order_ to the order_ of the one of the three chromosomes who had the best fitness value and deleted the clones. 

We adjusted the original Deme class to take ClimbChromosomes instead of Chromosomes, which was mostly just a matter of replacing; however, instead of also overriding the recombine method for ClimbChromosome, we chose to dynamic_cast each element of the pair after the fact in Deme. 

In TournamentDeme, the only function we overrode was select_parent (also written for ClimbChromosome). We pick a random index and put the parent at that index in a parents vector and repeat, so we have 32 parents. Then, while the vector has at least two parents, we take two parents out of the vector from the back, and insert the parent with the higher fitness back into the front of the vector (so they will not be immediately picked again- until the end of the process). Then there will be only one parent in the vector so we return a pointer to in. We do not override the compute_next_generation method, as the tournament aspect is entirely in select_parent.

For both, local and tournament tests, we saw worse results than with the baseline-ga; however, tournament did slightly better than local. We tested tournament with both ClimbChromosome and Chromosome, but we found little to no difference, so we submit the test with ClimbChromosome. 

In our attempt at the extra credit, we chose to try the heuristic greedy crossover (HGreX). In addition to rewritting create_crossover_child for the chromosome, we also created a new method of Cities called flight that takes the indices of two cities and returns the distance between them. In create_crossover_child, we make the child from a clone and create a vector, unvisited, that is all of the cities indices in order. We use this vector to track which cities we've written to the child's order_ vector. Once we add a city to the vector, we replace the value at that index with -1. To start, we pick a random city to write to the child's order_ and adjust the unvisited vector. Then we look at the next city in both of the parent orders, calculate the distances, and add the city that's closest to the child's order, unless that city has already been visited (-1 in unvisited vector). In that case, we try the further city from the other parent. If both cities have been visited, we consider the fitnesses of three random cities we haven't visited (or all of the remaining unvisited cities if there are less than 3), and take the city with the best distance as the next city in the child's order_. Then that city is the new starting place to measure the distances from, and we continue until we have written the entire order_ of the child, check that it's valid and return the child. 

Using HGreX, we got extremely improved results. Our population is converging to a total distance of around 7000.
